import{_ as s,c as n,o as a,a as l}from"./app.def0b298.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"1、JavaScript","slug":"_1、javascript","link":"#_1、javascript","children":[]},{"level":3,"title":"const命令两个注意点:","slug":"const命令两个注意点","link":"#const命令两个注意点","children":[]},{"level":3,"title":"let、const 使用场景:","slug":"let、const-使用场景","link":"#let、const-使用场景","children":[]},{"level":3,"title":"ES6 有哪些新特性？","slug":"es6-有哪些新特性","link":"#es6-有哪些新特性","children":[]},{"level":3,"title":"call、apply、bind 区别？bind实现？bind 之后还能修改 this 指向吗？为什么？","slug":"call、apply、bind-区别-bind实现-bind-之后还能修改-this-指向吗-为什么","link":"#call、apply、bind-区别-bind实现-bind-之后还能修改-this-指向吗-为什么","children":[]},{"level":3,"title":"闭包概念，最主要的还是问闭包的场景？","slug":"闭包概念-最主要的还是问闭包的场景","link":"#闭包概念-最主要的还是问闭包的场景","children":[]},{"level":3,"title":"原型、原型链(高频)","slug":"原型、原型链-高频","link":"#原型、原型链-高频","children":[]},{"level":3,"title":"this 指向、new 关键字","slug":"this-指向、new-关键字","link":"#this-指向、new-关键字","children":[]},{"level":3,"title":"用es5实现es6类的继承？","slug":"用es5实现es6类的继承","link":"#用es5实现es6类的继承","children":[]},{"level":3,"title":"JS 的运行机制","slug":"js-的运行机制","link":"#js-的运行机制","children":[]}],"relativePath":"js/index.md","lastUpdated":1679387290000}'),e={name:"js/index.md"},p=l(`<h3 id="_1、javascript" tabindex="-1">1、JavaScript <a class="header-anchor" href="#_1、javascript" aria-hidden="true">#</a></h3><p><code>js数据类型</code>？基本和引用的区别？<code>symbol</code>和<code>bigint</code>讲一讲应用场景？</p><ol><li><code>string、number、boolean、null、undefined、object(function、array)、symbol(ES10 BigInt)</code> 自定义私有属性使用 symbol,由于任何两个<code>symbol</code>都是不相等的，在 JavaScript 里可以很方便地用来模拟私有属性 BigInt 数据类型的目的是比<code>Number</code>数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用<code>BigInt</code>，整数溢出将不再是问题。</li></ol><ul><li>判断数据类型的方法？<code>instanceof</code>原理?判断<code>空对象</code>？ <code>typeof null</code>？<code>typeof NaN</code>？</li></ul><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#abb2bf;">typeof</span></span>
<span class="line"><span style="color:#abb2bf;">console.log(typeof und); // undefined</span></span>
<span class="line"><span style="color:#abb2bf;">console.log(typeof nul); // object</span></span>
<span class="line"><span style="color:#abb2bf;">console.log(typeof NAN); // number</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#b392f0;">typeof</span></span>
<span class="line"><span style="color:#b392f0;">console.log(typeof und); // undefined</span></span>
<span class="line"><span style="color:#b392f0;">console.log(typeof nul); // object</span></span>
<span class="line"><span style="color:#b392f0;">console.log(typeof NAN); // number</span></span>
<span class="line"><span style="color:#b392f0;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>其实 <code>instanceof</code> 主要的实现原理就是在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <code>prototype</code>，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。</p><ul><li>var/let/const 区别？<code>暂时性死区</code>？<code>块级作用域</code>？const a = {}; a.x = 1 能不能修改？</li></ul><ol><li>块级作用域</li><li>不存在变量提升 //在同一作用域下，变量可以在声明之前使用，值为 undefined</li><li>暂时性死区 // 只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，<strong>只有等到声明变量的那一行代码出现，才可以获取和使用该变量</strong></li><li>不可重复声明</li><li>let、const 声明的 \b 全局变量不会挂在顶层对象下面</li></ol><h3 id="const命令两个注意点" tabindex="-1"><code>const</code>命令两个注意点: <a class="header-anchor" href="#const命令两个注意点" aria-hidden="true">#</a></h3><ol><li>\b<code>let</code>可以先声明稍后再赋值,而<code>const</code>在 声明之后必须马上赋值，否则会报错</li><li>const 简单类型一旦声明就不能再更改，\b 复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。</li></ol><h3 id="let、const-使用场景" tabindex="-1">let、const 使用场景: <a class="header-anchor" href="#let、const-使用场景" aria-hidden="true">#</a></h3><ol><li><code>let</code>使用场景：变量，用以替代<code>var</code>。</li><li><code>const</code>使用场景：常量、声明匿名函数、箭头函数的时候。</li></ol><ul><li><p>说说你对<code>函数式编程</code>的理解？<code>函数柯里化</code>的理解？平时的使用场景？</p></li><li><p><code>防抖、节流</code>的含义，使用场景？<code>手写一下</code>？</p></li></ul><h3 id="es6-有哪些新特性" tabindex="-1">ES6 有哪些新特性？ <a class="header-anchor" href="#es6-有哪些新特性" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#abb2bf;">*   块作用域</span></span>
<span class="line"><span style="color:#abb2bf;">*   类</span></span>
<span class="line"><span style="color:#abb2bf;">*   箭头函数</span></span>
<span class="line"><span style="color:#abb2bf;">*   模板字符串</span></span>
<span class="line"><span style="color:#abb2bf;">*   加强的对象字面</span></span>
<span class="line"><span style="color:#abb2bf;">*   对象解构</span></span>
<span class="line"><span style="color:#abb2bf;">*   Promise</span></span>
<span class="line"><span style="color:#abb2bf;">*   模块</span></span>
<span class="line"><span style="color:#abb2bf;">*   Symbol</span></span>
<span class="line"><span style="color:#abb2bf;">*   代理（proxy）Set</span></span>
<span class="line"><span style="color:#abb2bf;">*   函数默认参数</span></span>
<span class="line"><span style="color:#abb2bf;">*   展开</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#b392f0;">*   块作用域</span></span>
<span class="line"><span style="color:#b392f0;">*   类</span></span>
<span class="line"><span style="color:#b392f0;">*   箭头函数</span></span>
<span class="line"><span style="color:#b392f0;">*   模板字符串</span></span>
<span class="line"><span style="color:#b392f0;">*   加强的对象字面</span></span>
<span class="line"><span style="color:#b392f0;">*   对象解构</span></span>
<span class="line"><span style="color:#b392f0;">*   Promise</span></span>
<span class="line"><span style="color:#b392f0;">*   模块</span></span>
<span class="line"><span style="color:#b392f0;">*   Symbol</span></span>
<span class="line"><span style="color:#b392f0;">*   代理（proxy）Set</span></span>
<span class="line"><span style="color:#b392f0;">*   函数默认参数</span></span>
<span class="line"><span style="color:#b392f0;">*   展开</span></span>
<span class="line"><span style="color:#b392f0;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="call、apply、bind-区别-bind实现-bind-之后还能修改-this-指向吗-为什么" tabindex="-1">call、apply、bind 区别？<code>bind实现</code>？bind 之后还能修改 this 指向吗？为什么？ <a class="header-anchor" href="#call、apply、bind-区别-bind实现-bind-之后还能修改-this-指向吗-为什么" aria-hidden="true">#</a></h3><p>三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，\`\` bind<code>方法通过传入一个对象，返回一个</code>this<code>绑定了传入对象的新函数。这个函数的</code>this<code>指向除了使用</code>new \`时会被改变，其他情况下都不会改变。</p><h3 id="闭包概念-最主要的还是问闭包的场景" tabindex="-1">闭包概念，最主要的还是问<code>闭包的场景</code>？ <a class="header-anchor" href="#闭包概念-最主要的还是问闭包的场景" aria-hidden="true">#</a></h3><p>闭包是指有权访问另一个函数作用域中的变量的函数 ——《JavaScript 高级程序设计》</p><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，</p><p>即使函数是在当前词法作用域之外执行 ——《你不知道的 JavaScript》</p><ul><li><p>闭包用途：</p><ol><li>能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li>私有化变量</li><li>模拟块级作用域</li><li>创建模块</li></ol></li><li><p>闭包缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p></li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#56B6C2;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">能够访问其它函数内部变量的函数</span><span style="color:#ABB2BF;">，</span><span style="color:#E06C75;">称为闭包</span></span>
<span class="line"><span style="color:#56B6C2;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">能够访问自由变量的函数</span><span style="color:#ABB2BF;">，</span><span style="color:#E06C75;">称为闭包</span><span style="color:#ABB2BF;"> ​ </span><span style="color:#E06C75;">场景</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">至于闭包的使用场景</span><span style="color:#ABB2BF;">，</span><span style="color:#E06C75;">其实在日常开发中使用到是非常频繁的</span></span>
<span class="line"><span style="color:#ABB2BF;">​ </span><span style="color:#56B6C2;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">防抖节流函数</span></span>
<span class="line"><span style="color:#56B6C2;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">定时器回调</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">等就不一一列举了</span></span>
<span class="line"><span style="color:#ABB2BF;">​ </span><span style="color:#E06C75;">优点</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">闭包帮我们解决了什么问题呢</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">**</span><span style="color:#E06C75;">内部变量是私有的</span><span style="color:#ABB2BF;">，</span><span style="color:#E06C75;">可以做到隔离作用域</span><span style="color:#ABB2BF;">，</span><span style="color:#E06C75;">保持数据的不被污染性</span><span style="color:#56B6C2;">**</span></span>
<span class="line"><span style="color:#ABB2BF;">​ </span><span style="color:#E06C75;">缺点</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">同时闭包也带来了不小的坏处</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">**</span><span style="color:#61AFEF;">说到了它的优点</span><span style="color:#98C379;">\`内部变量是私有的,可以做到隔离作用域\`</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">那也就是说垃圾回收机制是无法清理闭包中内部变量的</span><span style="color:#ABB2BF;">，</span><span style="color:#E06C75;">那最后结果就是内存泄漏</span><span style="color:#56B6C2;">**</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#F97583;">-</span><span style="color:#B392F0;"> 能够访问其它函数内部变量的函数，称为闭包</span></span>
<span class="line"><span style="color:#F97583;">-</span><span style="color:#B392F0;"> 能够访问自由变量的函数，称为闭包 ​ 场景 至于闭包的使用场景，其实在日常开发中使用到是非常频繁的</span></span>
<span class="line"><span style="color:#B392F0;">​ </span><span style="color:#F97583;">-</span><span style="color:#B392F0;"> 防抖节流函数</span></span>
<span class="line"><span style="color:#F97583;">-</span><span style="color:#B392F0;"> 定时器回调 </span><span style="color:#F97583;">-</span><span style="color:#B392F0;"> 等就不一一列举了</span></span>
<span class="line"><span style="color:#B392F0;">​ 优点 闭包帮我们解决了什么问题呢 </span><span style="color:#F97583;">**</span><span style="color:#B392F0;">内部变量是私有的，可以做到隔离作用域，保持数据的不被污染性</span><span style="color:#F97583;">**</span></span>
<span class="line"><span style="color:#B392F0;">​ 缺点 同时闭包也带来了不小的坏处 </span><span style="color:#F97583;">**</span><span style="color:#B392F0;">说到了它的优点</span><span style="color:#FFAB70;">\`内部变量是私有的,可以做到隔离作用域\`</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;">那也就是说垃圾回收机制是无法清理闭包中内部变量的，那最后结果就是内存泄漏</span><span style="color:#F97583;">**</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="原型、原型链-高频" tabindex="-1">原型、原型链(高频) <a class="header-anchor" href="#原型、原型链-高频" aria-hidden="true">#</a></h3><p><strong>原型:</strong> 对象中固有的<code>__proto__</code>属性，该属性指向对象的<code>prototype</code>原型属性。</p><p><strong>原型链:</strong> 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是<code>Object.prototype</code>所以这就是我们新建的对象为什么能够使用<code>toString()</code>等方法的原因。</p><p><strong>特点:</strong> <code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><h3 id="this-指向、new-关键字" tabindex="-1">this 指向、new 关键字 <a class="header-anchor" href="#this-指向、new-关键字" aria-hidden="true">#</a></h3><p><code>this</code>对象是是执行上下文中的一个属性，它指向最后一次调用这个方法的对象，在全局函数中，<code>this</code>等于<code>window</code>，而当函数被作为某个对象调用时，this 等于那个对象。 在实际开发中，<code>this </code>的指向可以通过四种调用模式来判断。</p><ol><li>函数调用，当一个函数不是一个对象的属性时，直接作为函数来调用时，<code>this</code>指向全局对象。</li><li>方法调用，如果一个函数作为一个对象的方法来调用时，<code>this</code>指向这个对象。</li><li>构造函数调用，<code>this</code>指向这个用<code>new</code>新创建的对象。</li><li>第四种是 <code>apply 、 call 和 bind </code>调用模式，这三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，\`\` bind<code>方法通过传入一个对象，返回一个</code>this<code>绑定了传入对象的新函数。这个函数的</code>this<code>指向除了使用</code>new \`时会被改变，其他情况下都不会改变。</li></ol><h3 id="用es5实现es6类的继承" tabindex="-1">用<code>es5实现es6</code>类的继承？ <a class="header-anchor" href="#用es5实现es6类的继承" aria-hidden="true">#</a></h3><blockquote><p>原型链继承 核心： 将父类的实例作为子类的原型</p></blockquote><blockquote><p>构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p></blockquote><blockquote><p>实例继承 核心：为父类实例添加新特性，作为子类实例返回</p></blockquote><blockquote><p>拷贝继承</p></blockquote><blockquote><p>组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现 函数复用</p></blockquote><blockquote><p>寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实 例方法/属性，避免的组合继承的缺点</p></blockquote><h3 id="js-的运行机制" tabindex="-1">JS 的运行机制 <a class="header-anchor" href="#js-的运行机制" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#abb2bf;">异步任务分类：宏任务，微任务</span></span>
<span class="line"><span style="color:#abb2bf;">同步任务和异步任务分别进入不同的执行&quot;场所&quot;</span></span>
<span class="line"><span style="color:#abb2bf;">先执行主线程执行栈中的宏任务</span></span>
<span class="line"><span style="color:#abb2bf;">执行过程中如果遇到微任务，进入Event Table并注册函数，完成后移入到微任务的任务队列中</span></span>
<span class="line"><span style="color:#abb2bf;">宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</span></span>
<span class="line"><span style="color:#abb2bf;">主线程会不断获取任务队列中的任务、执行任务、再获取、再执行任务也就是常说的Event Loop(事件循环)。</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#b392f0;">异步任务分类：宏任务，微任务</span></span>
<span class="line"><span style="color:#b392f0;">同步任务和异步任务分别进入不同的执行&quot;场所&quot;</span></span>
<span class="line"><span style="color:#b392f0;">先执行主线程执行栈中的宏任务</span></span>
<span class="line"><span style="color:#b392f0;">执行过程中如果遇到微任务，进入Event Table并注册函数，完成后移入到微任务的任务队列中</span></span>
<span class="line"><span style="color:#b392f0;">宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</span></span>
<span class="line"><span style="color:#b392f0;">主线程会不断获取任务队列中的任务、执行任务、再获取、再执行任务也就是常说的Event Loop(事件循环)。</span></span>
<span class="line"><span style="color:#b392f0;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div>`,39),o=[p];function c(i,t,r,d,b,y){return a(),n("div",null,o)}const B=s(e,[["render",c]]);export{u as __pageData,B as default};
