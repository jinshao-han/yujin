import{_ as e,c as a,o as t,a as _}from"./app.5146eedb.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"一次请求大量数据怎么优化，数据多导致渲染慢怎么优化","slug":"一次请求大量数据怎么优化-数据多导致渲染慢怎么优化","link":"#一次请求大量数据怎么优化-数据多导致渲染慢怎么优化","children":[]},{"level":3,"title":"虚拟列表","slug":"虚拟列表","link":"#虚拟列表","children":[]}],"relativePath":"algorithm/虚拟列表&大量数据渲染.md","lastUpdated":null}'),c={name:"algorithm/虚拟列表&大量数据渲染.md"},d=_('<h3 id="一次请求大量数据怎么优化-数据多导致渲染慢怎么优化" tabindex="-1">一次请求大量数据怎么优化，数据多导致渲染慢怎么优化 <a class="header-anchor" href="#一次请求大量数据怎么优化-数据多导致渲染慢怎么优化" aria-hidden="true">#</a></h3><p>首先大量数据的接收，那么肯定是用异步的方式进行接收，对数据进行一个分片处理，可以拆分成一个个的小单元数据，通过自定义的属性进行关联。这样数据分片完成。接下来渲染的话，由于是大量数据，如果是长列表的话，这里就可以使用虚拟列表（当前页面需要渲染的数据拿到进行渲染，然后对前面一段范围及后面一段范围，监听对应的滚动数据来切换需要渲染的数据，这样始终要渲染的就是三部分）。当然还有别的渲染情况，比如 echarts 图标大量点位数据优化等。</p><h3 id="虚拟列表" tabindex="-1">虚拟列表 <a class="header-anchor" href="#虚拟列表" aria-hidden="true">#</a></h3><p>实际上是一种实现方案，只对<code>可视区域</code>进行渲染，对<code>非可视区域</code>中的区域不渲染或只渲染一部分（渲染的部分叫<code>缓冲区</code>，不渲染的部分叫<code>虚拟区</code>），从而达到极高的性能</p>',4),o=[d];function r(n,s,i,l,h,p){return t(),a("div",null,o)}const f=e(c,[["render",r]]);export{u as __pageData,f as default};
