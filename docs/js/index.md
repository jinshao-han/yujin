### 1、JavaScript

`js数据类型`？基本和引用的区别？`symbol`和`bigint`讲一讲应用场景？

1.  `string、number、boolean、null、undefined、object(function、array)、symbol(ES10 BigInt)`
    自定义私有属性使用 symbol,由于任何两个`symbol`都是不相等的，在 JavaScript 里可以很方便地用来模拟私有属性
    BigInt 数据类型的目的是比`Number`数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用`BigInt`，整数溢出将不再是问题。

- 判断数据类型的方法？`instanceof`原理?判断`空对象`？ `typeof null`？`typeof NaN`？

```
typeof
console.log(typeof und); // undefined
console.log(typeof nul); // object
console.log(typeof NAN); // number
```

其实 `instanceof` 主要的实现原理就是在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 `prototype`，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。

- var/let/const 区别？`暂时性死区`？`块级作用域`？const a = {}; a.x = 1 能不能修改？

1.  块级作用域
2.  不存在变量提升 //在同一作用域下，变量可以在声明之前使用，值为 undefined
3.  暂时性死区 // 只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，**只有等到声明变量的那一行代码出现，才可以获取和使用该变量**
4.  不可重复声明
5.  let、const 声明的  全局变量不会挂在顶层对象下面

### `const`命令两个注意点:

1.  `let`可以先声明稍后再赋值,而`const`在 声明之后必须马上赋值，否则会报错
2.  const 简单类型一旦声明就不能再更改， 复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。

### let、const 使用场景:

1.  `let`使用场景：变量，用以替代`var`。
2.  `const`使用场景：常量、声明匿名函数、箭头函数的时候。

- 说说你对`函数式编程`的理解？`函数柯里化`的理解？平时的使用场景？

- `防抖、节流`的含义，使用场景？`手写一下`？

### ES6 有哪些新特性？

```
*   块作用域
*   类
*   箭头函数
*   模板字符串
*   加强的对象字面
*   对象解构
*   Promise
*   模块
*   Symbol
*   代理（proxy）Set
*   函数默认参数
*   展开
```

### call、apply、bind 区别？`bind实现`？bind 之后还能修改 this 指向吗？为什么？

三个方法都可以显示的指定调用函数的 this 指向。`apply`接收参数的是数组，`call`接受参数列表，`` bind`方法通过传入一个对象，返回一个`this` 绑定了传入对象的新函数。这个函数的 `this`指向除了使用`new `时会被改变，其他情况下都不会改变。

### 闭包概念，最主要的还是问`闭包的场景`？

闭包是指有权访问另一个函数作用域中的变量的函数 ——《JavaScript 高级程序设计》

当函数可以记住并访问所在的词法作用域时，就产生了闭包，

即使函数是在当前词法作用域之外执行 ——《你不知道的 JavaScript》

- 闭包用途：

  1.  能够访问函数定义时所在的词法作用域(阻止其被回收)
  2.  私有化变量
  3.  模拟块级作用域
  4.  创建模块

- 闭包缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏

```js
- 能够访问其它函数内部变量的函数，称为闭包
- 能够访问自由变量的函数，称为闭包 ​ 场景 至于闭包的使用场景，其实在日常开发中使用到是非常频繁的
​ - 防抖节流函数
- 定时器回调 - 等就不一一列举了
​ 优点 闭包帮我们解决了什么问题呢 **内部变量是私有的，可以做到隔离作用域，保持数据的不被污染性**
​ 缺点 同时闭包也带来了不小的坏处 **说到了它的优点`内部变量是私有的,可以做到隔离作用域`,那也就是说垃圾回收机制是无法清理闭包中内部变量的，那最后结果就是内存泄漏**
```

### 原型、原型链(高频)

**原型:** 对象中固有的`__proto__`属性，该属性指向对象的`prototype`原型属性。

**原型链:** 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是`Object.prototype`所以这就是我们新建的对象为什么能够使用`toString()`等方法的原因。

**特点:** `JavaScript`对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

### this 指向、new 关键字

`this`对象是是执行上下文中的一个属性，它指向最后一次调用这个方法的对象，在全局函数中，`this`等于`window`，而当函数被作为某个对象调用时，this 等于那个对象。 在实际开发中，`this `的指向可以通过四种调用模式来判断。

1.  函数调用，当一个函数不是一个对象的属性时，直接作为函数来调用时，`this`指向全局对象。
2.  方法调用，如果一个函数作为一个对象的方法来调用时，`this`指向这个对象。
3.  构造函数调用，`this`指向这个用`new`新创建的对象。
4.  第四种是 `apply 、 call 和 bind `调用模式，这三个方法都可以显示的指定调用函数的 this 指向。`apply`接收参数的是数组，`call`接受参数列表，`` bind`方法通过传入一个对象，返回一个`this` 绑定了传入对象的新函数。这个函数的 `this`指向除了使用`new `时会被改变，其他情况下都不会改变。

### 用`es5实现es6`类的继承？

> 原型链继承 核心： 将父类的实例作为子类的原型

> 构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类

> 实例继承 核心：为父类实例添加新特性，作为子类实例返回

> 拷贝继承

> 组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现 函数复用

> 寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实 例方法/属性，避免的组合继承的缺点

### JS 的运行机制

```
异步任务分类：宏任务，微任务
同步任务和异步任务分别进入不同的执行"场所"
先执行主线程执行栈中的宏任务
执行过程中如果遇到微任务，进入Event Table并注册函数，完成后移入到微任务的任务队列中
宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
主线程会不断获取任务队列中的任务、执行任务、再获取、再执行任务也就是常说的Event Loop(事件循环)。
```
