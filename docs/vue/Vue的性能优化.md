```js
1、`v-if`和`v-show`

*   频繁切换时使用`v-show`，利用其缓存特性
*   首屏渲染时使用`v-if`，如果为`false`则不进行渲染

2、`v-for`的`key`

*   列表变化时，循环时使用唯一不变的`key`，借助其本地复用策略
*   列表只进行一次渲染时，`key`可以采用循环的`index`

3、侦听器和计算属性

*   侦听器`watch`用于数据变化时引起其他行为
*   多使用`compouter`计算属性顾名思义就是新计算而来的属性，如果依赖的数据未发生变化，不会触发重新计算

4、合理使用生命周期

*   在`destroyed`阶段进行绑定事件或者定时器的销毁
*   使用动态组件的时候通过`keep-alive`包裹进行缓存处理，相关的操作可以在`actived`阶段激活

5、数据响应式处理

*   不需要响应式处理的数据可以通过`Object.freeze`处理，或者直接通过`this.xxx = xxx`的方式进行定义
*   需要响应式处理的属性可以通过`this.$set`的方式处理，而不是`JSON.parse(JSON.stringify(XXX))`的方式

6、路由加载方式

*   页面组件可以采用异步加载的方式

7、插件引入

*   第三方插件可以采用按需加载的方式，比如`element-ui`。

8、减少代码量

*   采用`mixin`的方式抽离公共方法
*   抽离公共组件
*   定义公共方法至公共`js`中
*   抽离公共`css`

9、编译方式

*   如果线上需要`template`的编译，可以采用完成版`vue.esm.js`
*   如果线上无需`template`的编译，可采用运行时版本`vue.runtime.esm.js`，相比完整版体积要小大约`30%`

10、渲染方式

*   服务端渲染，如果是需要`SEO`的网站可以采用服务端渲染的方式
*   前端渲染，一些企业内部使用的后端管理系统可以采用前端渲染的方式

11、字体图标的使用

*   有些图片图标尽可能使用字体图标
```

编码阶段

```

尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
v-if和v-for不能连用
如果需要使用v-for给每项元素绑定事件时使用事件代理
SPA 页面采用keep-alive缓存组件
在更多的情况下，使用v-if替代v-show
key保证唯一
使用路由懒加载、异步组件
防抖、节流
第三方模块按需导入
长列表滚动到可视区域动态加载
图片懒加载
SEO优化
预渲染
服务端渲染SSR
打包优化
压缩代码
Tree Shaking/Scope Hoisting
使用cdn加载第三方模块
多线程打包happypack
splitChunks抽离公共文件
sourceMap优化
用户体验
骨架屏
PWA
还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。
```
